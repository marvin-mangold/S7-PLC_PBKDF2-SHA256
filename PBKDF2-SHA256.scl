FUNCTION "PBKDF2-SHA256" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      inputmode : Int;   // 1 = Bytes, 2 = String, 
      outputmode : Int;   // 1 = digest,  2 = hexdigest , 3 = both
      passwordBytes : Array[0..253] of Byte;   // Password as Bytes
      passwordBytesLen : Int;   // number of used Bytes in passwordBytes
      passwordString : String;   // Password as String
      saltBytes : Array[0..253] of Byte;   // Salt as Bytes
      saltBytesLen : Int;   // number of used Bytes in passwordBytes
      saltString : String;   // Password as String
      iterations : DInt;   // number of Iterations
   END_VAR

   VAR_OUTPUT 
      derivedKey : Array[0..31] of Byte;   // DK
   END_VAR

   VAR_TEMP 
      Password : Struct
         bytes : Array[0..253] of Byte;
         len : Int;
      END_STRUCT;
      Salt : Struct
         bytes : Array[0..253] of Byte;
         len : Int;
      END_STRUCT;
      l : DInt;   // number of hLen-octet blocks in the derived key
      r : DInt;   // number of octets in the last
      i : DInt;
      iBytes : Array[0..3] of Byte;
      cntT : Int;
      cntU : Int;
      cntXor : Int;
      Unow : Array[0..253] of Byte;
      Ulast : Array[0..31] of Byte;
      xSum : Array[0..31] of Byte;
      tempUInt : UInt;
      tempString : String;
   END_VAR

   VAR CONSTANT 
      hLen : DInt := 32;   // hLen
      dkLen : DInt := 32;   // dkLen
   END_VAR


BEGIN
	#l := CEIL(#dkLen / #hLen);
	#r := #dkLen - (1-1) * #hLen;
	
	REGION Convert and copy Inputs
	    // copy Password in Password.bytes and save the number of Bytes Password.len
	    IF #inputmode = 1 THEN
	        MOVE_BLK(IN:=#passwordBytes[0], COUNT:=MIN(IN1:=#passwordBytesLen, IN2:=254), OUT=>#Password.bytes[0]);
	        #Password.len := MIN(IN1:=#passwordBytesLen, IN2:=254);
	    ELSIF #inputmode = 2 THEN
	        Strg_TO_Chars(Strg := #passwordString, pChars := 0, Cnt => #tempUInt, Chars := #Password.bytes);
	        #Password.len := UINT_TO_INT(#tempUInt);
	    END_IF;
	    
	    // copy Salt in Salt.bytes and save the number of Bytes Salt.len
	    IF #inputmode = 1 THEN
	        MOVE_BLK(IN:=#saltBytes[0], COUNT:=MIN(IN1:=#saltBytesLen, IN2:=254), OUT=>#Salt.bytes[0]);
	        #Salt.len := MIN(IN1:=#saltBytesLen, IN2:=254);
	    ELSIF #inputmode = 2 THEN
	        Strg_TO_Chars(Strg := #saltString, pChars := 0, Cnt => #tempUInt, Chars := #Salt.bytes);
	        #Salt.len := UINT_TO_INT(#tempUInt);
	    END_IF;
	END_REGION
	
	FOR #cntT := 1 TO #l DO
	    #i := #cntT;
	    #iBytes[0] := #i.%B3;
	    #iBytes[1] := #i.%B2;
	    #iBytes[2] := #i.%B1;
	    #iBytes[3] := #i.%B0;
	    MOVE_BLK(IN:=#Salt.bytes[0], COUNT:=#Salt.len, OUT=>#Unow[0]);
	    MOVE_BLK(IN:=#iBytes[0], COUNT:=4, OUT=>#Unow[#Salt.len]);
	    
	    // first iteration
	    "HMAC-SHA256"(inputmode:=1, outputmode:=1, messageBytes:=#Unow, messageBytesLen:=#Salt.len + 4, messageString:=#tempString, keyBytes:=#Password.bytes, keyBytesLen:=#Password.len, keyString:=#tempString, digest=>#Ulast, hexdigest=>#tempString);
	    #xSum := #Ulast;
	    
	    // perform the other iterations
	    FOR #cntU := 1 TO (#iterations - 1) DO
	        MOVE_BLK(IN:=#Ulast[0], COUNT:=32, OUT=>#Unow[0]);
	        "HMAC-SHA256"(inputmode:=1, outputmode:=1, messageBytes:=#Unow, messageBytesLen:=32, messageString:=#tempString, keyBytes:=#Password.bytes, keyBytesLen:=#Password.len, keyString:=#tempString, digest=>#Ulast, hexdigest=>#tempString);
	        FOR #cntXor := 0 TO 31 DO
	            #xSum[#cntXor] := #Ulast[#cntXor] XOR #xSum[#cntXor];
	        END_FOR;
	    END_FOR;
	END_FOR;
	
	#derivedKey := #xSum;
END_FUNCTION

